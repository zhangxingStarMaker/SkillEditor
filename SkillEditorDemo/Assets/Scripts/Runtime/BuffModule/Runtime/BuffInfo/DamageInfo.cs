using System;
using Module.FrameBase;
using UnityEngine;

namespace BuffModule.Runtime
{
    public class DamageInfo
    {
        /// <summary>
        /// 攻击者的GameObject，也就是发起这次伤害信息的攻击者，这个攻击者当然可以是空的，因为并不是所有的伤害都是人为造成的，
        /// 比如说我们走到关卡中某个地刺上的时候，攻击者并不是一个角色，这时候Attacker应该是空
        /// </summary>
        public CoreEntity Attacker;
        
        /// <summary>
        /// 受到伤害的角色的GameObject，这个角色必须是存在的，如果是空，那么这条伤害信息就没有任何意义了。
        /// 同样的，根据游戏的设定，大多游戏中Defender如果已经挂了，也一样会把这条数据销毁了.
        /// </summary>
        public CoreEntity Defender;
        
        /// <summary>
        /// 字符串数组，伤害类型的tag
        /// 这在buff的脚本逻辑中会是一个非常重要的元素。这里是策划的游戏设计中必须定义清楚的东西，它是用来描述一个伤害的类型的，
        /// 这个类型并不是说比如“冰冻伤害”、“火焰伤害”之类的不同的属性伤害的，而是用来描述“伤害源”类似的东西的，比如是“直接伤害”、“间歇伤害”、“反弹伤害”等等，
        /// 这些定义都是因游戏而已的，并不是一个固定的范式。比如当我们要做一个buff，这个buff的效果是“反弹受到的伤害给攻击者”，
        /// 如果攻防双方（设为A和B两个角色）身上都有这个buff，就会发生：A对B产生伤害，之后B的buff反弹伤害给A形成B对A造成伤害，这时候A的Buff又生效了，反弹给B，
        /// 这样会发生一个“短路”现象，直到A或者B有一方作为defender的时候被击败了，循环才会终止。所以此时，我们需要根据DamageInfo的tag来判断，
        /// 这个伤害对于这个buff来说该不该发生反弹，由此避免类似的死循环问题。而除此之外，我们还会遇到很多类似“受到直接伤害的时候伤害降低最多50点”之类的效果，
        /// 都是需要通过tag来判断这次伤害的类型的。
        /// </summary>
        public string[] Tags;

        /// <summary>
        /// 一个伤害数据结构，这是根据游戏不同来设计的，比如游戏中有金木水火土外加物理攻击，那么他就应该是有6个伤害数字组成的。
        /// 我们通常忽略的一种情况是——策划会设计一些针对游戏中“元素属性”类似的东西有效的效果，比如“受到的火焰伤害减半”，如果此时受到的攻击是一个“暗影烈焰”，
        /// 即暗属性伤害200点+火属性伤害200点，那么就得从这里面去找到暗影属性伤害减去一半；再比如“短时间内抑制所有受到的子弹伤害”，
        /// 那么这个伤害的数据里面有一条肯定是子弹伤害，将子弹伤害设定为0，就抑制了。
        /// </summary>
        public DamageData DamageData;

        /// <summary>
        /// 伤害的角度
        /// 也就是伤害打向defender的入射角度，通常这个角度来源是取子子弹的飞行方向或者aoe的中心点指向角色的位置的。
        /// 这个角度配合角色当前的面向角度，就可以算出角色什么方向受到了伤害，假如需要做类似“背刺”的效果，那就得用上这个。
        /// 例如:荆轲的背刺技能
        /// </summary>
        public Vector3 DamageDegree;

        /// <summary>
        /// 本次攻击的最终暴击率
        /// 大多游戏还是有暴击设计的，如果没有，可以砍掉这个数据。当一次伤害信息经历了所有流程之后，将最后的数值传递给策划编写的公式脚本，
        /// 由策划来处理是否暴击了，以及暴击造成多少伤害
        /// </summary>
        public float CriticalRate;

        /// <summary>
        /// 和暴击率类似的概念，但是他俩在逻辑流程中实际上并无直接关系，即当有一个效果是“下一次攻击必定暴击”，这时候的DamageInfo哪怕hitRate是<=0的数字，
        /// 也不妨碍criticalRate被设置为1或者更高的数字(假如策划认为1代表100%，这完全是由设计数值公式的策划来定义的),这两者并无依赖关系，不是说不命中就一定不能暴击，
        /// 最后不命中能不能暴击，暴击了是不是一定命中,还是看策划写的公式脚本如何认为。
        /// </summary>
        public float HitRate;

        /// <summary>
        /// 这是一个“隐藏属性”，所以在上述结构中并没有标明，但是非常有必要说明一下。因为在整个伤害的流程中，我们可能因为一些角色身上的buff效果，
        /// 他会需要添加新的buff效果，而这个新的buff效果并不想马上添加给角色（通常都是如此），比如说攻击者有一个buffA，他的效果是“攻击后目标受到割裂影响”，
        /// 也就是在目标身上上一个buffB；还有一个优先级更低（更晚执行）的buffC，是“对割裂的目标造成的伤害提高200%”，策划设计的时候的想法是，这次攻击造成割裂，
        /// 下次才是3倍伤害，但是因为执行顺序，产生了本次就直接上了割裂并且3倍伤害，我们不能让策划因为这个去调整buff的优先级，因为这会导致逻辑混乱，
        /// 优先级本身是期望某些必然又先后关系的buff之间用的，这种其实对于策划设计的思路来说，是“非必然的先后顺序”，因此理论上来说，
        /// 策划完全可以用buff的priority来解决这个问题，但这属于设计burden，因此我们通过在DamageInfo中添加这么一个List，把在流程中的这些AddBuffInfo储存在这里，在完成流程后执行.
        /// 而策划要做的则是在BuffOnHit、BuffBeHurt、BuffOnKill、BuffBeKilled中产生的buff来添加给这个damageInfo
        /// </summary>
        public int[] AddBuffs;

    }
}